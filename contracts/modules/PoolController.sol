// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.0;

import "../shared/CoreController.sol";

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Pausable.sol";
import "@openzeppelin/contracts/utils/Context.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract PoolController is
    Context,
    CoreController,
    ERC721Enumerable,
    ERC721Pausable
{
    using Counters for Counters.Counter;

    bytes32 public constant NAME = "PoolController";

    Counters.Counter private _tokenIdTracker;
    mapping (uint256 => bytes) public tokenData;

    /**
     * @dev
     * TODO: Check if we need this: Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * See {ERC721-tokenURI}.
     */
    constructor(
        string memory name,
        string memory symbol
    ) ERC721(name, symbol)
    {
    }

    /**
     * @dev Creates a new token for `to`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_mint}.
     *
     * Requirements:
     *
     * TODO t.b.d.
     */
    function mintRiskPoolNft(
        address to,
        uint256 capacity,
        bytes32 data
    )
        public
    {
        require(/* TODO add requirement */ true);

        // We cannot just use balanceOf to create the new tokenId because tokens
        // can be burned (destroyed), so we need a separate counter.
        uint256 tokenId =_tokenIdTracker.current();
        _mint(to, tokenId);
        tokenData[tokenId] = data;
        _tokenIdTracker.increment();
    }


    function burnRiskPoolNft(
        uint256 tokenId
    )
        public
    {
        require(/* TODO add requirement */ true);

        _burn(tokenId);
        delete tokenData[tokenId];

    }


    /**
     * @dev Pauses all token transfers.
     *
     * See {ERC721Pausable} and {Pausable-_pause}.
     *
     * Requirements:
     *
     * TODO t.b.d.
     */
    function pause()
        public virtual
    {
        require(/* TODO add requirement */ true);
        _pause();
    }

    /**
     * @dev Unpauses all token transfers.
     *
     * See {ERC721Pausable} and {Pausable-_unpause}.
     *
     * Requirements:
     *
     * TODO t.b.d.
     */
    function unpause()
        public virtual
    {
        require(/* TODO add requirement */ true);
        _unpause();
    }

    /**
     * @dev Pause a specific NFT. This NFT will not accept further policies.
     *
     * Requirements:
     *
     * TODO t.b.d.
     */
    function pauseRiskPoolNft (
        uint256 tokenId
    )
        public
    {

    }

    /**
     * @dev Unpause a specific NFT. This NFT will resume to accept further policies.
     *
     * Requirements:
     *
     * TODO t.b.d.
     */
    function unpauseRiskPoolNft (
        uint256 tokenId
    )
        public
    {

    }

    /**
     * @dev Add capacity to a specific NFT.
     *
     * Requirements:
     *
     * TODO t.b.d.
     */
    function addCapacity (
        uint256 tokenId,
        uint256 capacity
    )
        public
    {

    }

    /**
     * @dev Reduce Capacity of a specific NFT. Only free capacity can be reduced.
     *
     * Requirements:
     *
     * TODO t.b.d.
     */
    function reduceCapacity (
        uint256 tokenId,
        uint256 capacity
    )
        public
    {

    }

    /**
     * @dev Called by the product to signal new policy.
     *
     * Requirements:
     *
     * TODO t.b.d.
     */
    function newPolicy (
        bytes32 bpKey, uint256 premium, uint256 sumInsured
    )
        public
    {

    }

    /**
     * @dev Called by the product to signal that a policy has expired.
     *
     * Requirements:
     *
     * TODO t.b.d.
     */
    function expirePolicy (
        bytes32 bpKey
    )
        public
    {

    }


	/**
     * @dev Called by the product to signal that a claim has been filed.
     *
     * Requirements:
     *
     * TODO t.b.d.
     */
    function claimPolicy (
        bytes32 bpKey,
        uint256 claimsAmount
    )
        public
    {

    }


	/**
     * @dev Allocate a policy to a specific NFT.
     *
     * Requirements:
     *
     * TODO t.b.d.
     */
    function allocatePolicy (
        bytes32 bpKey,
        uint256 capacity
    )
        public
    {

    }


	/**
     * @dev Deallocate a policy from a specific NFT.
     *
     * Requirements:
     *
     * TODO t.b.d.
     */
    function deallocatePolicy (
        bytes32 bpKey,
        uint256 capacity
    )
        public
    {

    }


	/**
     * @dev Get the allocated capacity for a policy.
     *
     * Requirements:
     *
     * TODO t.b.d.
     */
    function getAllocatedCapacity (
        bytes32 bpKey
    )
        public
    {

    }


	/**
     * @dev Get unallocated capacity for a policy.
     *
     * Requirements:
     *
     * TODO t.b.d.
     */
    function getUnallocatedCapacity (
        bytes32 bpKey
    )
        public
    {

    }


	/**
     * @dev Get total free capacity
     *
     * Requirements:
     *
     * TODO t.b.d.
     */
    // function getTotalFreeCapacity () public {}


	/**
     * @dev Pause a specific NFT. This NFT will not accept further policies.
     *
     * Requirements:
     *
     * TODO t.b.d.
     */
    // function getTotalExposure () public {}


	/**
     * @dev Pause a specific NFT. This NFT will not accept further policies.
     *
     * Requirements:
     *
     * TODO t.b.d.
     *
    function getNftPrice (uint256 tokenId)
        public
        returns (uint256 price)
    {}
    */

	/**
     * @dev Pause a specific NFT. This NFT will not accept further policies.
     *
     * Requirements:
     *
     * TODO t.b.d.
     */
    function getNftExposure (
        uint256 tokenId
    )
        public
        returns (uint256 exposure)
    {
        exposure = 0; // TODO
    }


	/**
     * @dev Pause a specific NFT. This NFT will not accept further policies.
     *
     * Requirements:
     *
     * TODO t.b.d.
     */
    function getNftCapacity (
        uint256 tokenId
    )
        public
        returns (uint256 capacity)
    {
        capacity = 0; // TODO
    }


	/**
     * @dev Pause a specific NFT. This NFT will not accept further policies.
     *
     * Requirements:
     *
     * TODO t.b.d.
     */
    function getNftPremiumsPaid (
        uint256 tokenId
    )
        public
        returns (uint256 premiumsPaid)
    {
        premiumsPaid = 0; // TODO
    }

    /**
     * @dev Pause a specific NFT. This NFT will not accept further policies.
     *
     * Requirements:
     *
     * TODO t.b.d.
     */
    function getNftClaimsAdjusted (
        uint256 tokenId
    )
        public
        returns (uint256 claimsAdjusted)
    {
        claimsAdjusted = 0; // TODO
    }




    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    )
    internal virtual override(ERC721, ERC721Enumerable, ERC721Pausable)
    {
        super._beforeTokenTransfer(from, to, tokenId);
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(
        bytes4 interfaceId
    )
        public view virtual
        override(ERC721, ERC721Enumerable)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }

}
